<!DOCTYPE html>
<html lang="ko">
<head>Big O notation</head>
<body>
    <!--
      📌 Objectives
    -->
    1. 빅오 표기법의 필요성<br>
    2. 시간 복잡성과 공간 복잡성 정의<br>
    3. 빅오 표기법을 활용한 알고리즘 평가<br>
    4. logarithm<br>
    5. 시간 복잡성과 공간 복잡성 정의<br>

    <!-- 
      ✅ 빅오 표기법의 필요성
     -->
    🔹 빅오란 무엇일까? 
      - 여러가지 코드를 일반적으로 서로 비교하고 성능을 평가하는 방법

    🔹 더 나은 코드란?
      - 코드 시간 재기
      - 만들어지는 데이터의 갯수
      - 얼마나 쉽게(짧게) 코드를 읽을 수 있는지?
        
    🔹 코드 시간 재기 => 타이밍 펑션 performance.now()
      <script>
        function addUpToUseLoof(n) {
          let total = 0;
          
          for (let i = 1; i <= n; i++) {
              total += i;
          }
          return total;
        }

        let t1 = performance.now();
        addUpToUseLoof(1000000000);
        let t2 = performance.now();
        console.log(`Loof - Time Elapsed: ${(t2 - t1) / 1000} secondes`);

        function addUpTo(n) {
          return n * (n + 1) / 2;
        }

        let t3 = performance.now();
        addUpTo(1000000000);
        let t4 = performance.now();
        console.log(`Time Elapsed: ${(t4 - t3) / 1000} secondes`);
      </script>

    🔹 정말 소요시간만으로 코드가 더 낫다고 판단할 수 있을까?
      - 기기마다 다른 소요 시간을 가지므로 체크해야할 가짓수가 많을 것이다.
      - 똑같은 기계(브라우저)에서도 다른 시간을 측정하기도 한다.
      - 빠른 알고리즘에서는 정말 짧은 시간 안에 모든 것이 처리가 되기 때문에 비교 측정이 올바르지 않을 수 있다.
  
    🔹 그렇다면 어떤 방법으로 더 나은 코드를 판단할 수 있을까?
      - Big O: 컴퓨터가 처리해야하는 연산 갯수를 세면 된다.
        addUpToUseLoof: 연산 5n + 2번
        addUpTo: 연산 3번 (상수)

    <!-- 
      ✅ 2-1. 시간복잡도
     -->
    🔹 빅오의 개념
      - 입력의 크기와 실행시간의 관계를 말한다. "시간복잡도" 라고 할 수 있다.
        addUpToUseLoof: O(n) => n이 커질수록 실행시간이 1:1 비율로 늘어나고, 연산의 갯수는 궁극적으로 n의 곱과 연결되어 있다.  
        addUpTo: O(1) => 1은 상수를 의미한다. n의 값이 커질 수록, 실행시간에 변함이 없다.
        (만약 중첩루프가 있다면 O(n^2)가 된다.)

    🔹 빅오 표현법의 단순화 규칙
      - O(2n) => O(n)
      - O(500) => O(1)
      - O(13n^) => O(n^)

    🔹 실행시간 비교
      1. 산수(연산)는 상수다.
      2. 변수 배정도 상수다. 
      3. 인데스를 사용해서 배열 엘리먼트에 접근하는 것은 상수다. 
      4. 루프가 있다면 실행시간은 무조건 O(n)일까? 그렇지는 않다.
        <script>
          // O(n) : n이 커질수록 루프는 계속 실행되기 때문에 n의 값과 루프의 길이가 비례한다.
          function logAtLeast5 (n) {
            for (var i = 1; i <= Math.max(5, n); i++) {
              console.log(i);
            }
          }

          // O(5) => O(1) : n이 커질수록 루프는 계속 실행되지만 n이 5이상의 값이 되는 순간 조건문에 의해 루프가 실행되지 않기 때문에 n의 값과 루프의 길이는 비례하지 않는다.
          function logAtMost5 (n) {
            for (var i = 1; i <= Math.min(5, n); i++) {
              console.log(i);
            }
          }
        </script>

    <!-- 
      ✅ 2-2. 공간복잡도
     -->
    🔹 공간복잡도란? (=> 보조공간복잡도)
      - 만들어지는 데이터의 갯수를 말한다.
      - 입력(n)이 커질수록 알고리즘이 공간(메모리)을 차지하는 비율은 비례한다.
      - 보조 공간 복잡도란,입력되는 것을 제외하고 알고리즘 자체가 필요로 하는 공간을 의미한다.
      - 우리가 알아볼 것은 입력과 관계 없는 '보조 공간 복잡도' 이다.
    
    🔹 공간 in JS
      - bool, number, undefined, null은 자바스크립트에서 모두 불변의 공간이다.
      - 입력의 크기와는 상관없이, 숫자가 1이든 100든 모두 불변의 공간이라고 여겨진다.
      - 문자열은 조금 다르다. 문자열은 O(n) 공간이 필요하다. 배열과 객체도 마찬가지이다. (배열길이, key갯수)
        <script>
          // O(1) space 입력의 크기와는 상관 없이 항상 똑같다.
          function sum(arr) {
            let total = 0; // one nuber
            for (let i = 0; i < arr.length; i++) { // let i = 0; another number
              total += arr[i];
            }
            return total;
          }

          // O(n) space 입력의 크기와 비례하여 커진다.
          function sum(arr) {
            let newArr = []; // 여기서 빈 배열은 크게 중요치 않다.
            for (let i = 0; i < arr.length; i++) { 
              newArr.push(2 * arr[i]); // n numbers 차지 공간이 입력된 배열의 크기와 비례해서 커지게 된다.
            }
            return newArr;
          }
        </script>

    <!-- 
      ✅ 3. logarithm
     -->
    🔹 로그는 무엇인가?
      - 로그함수는 지수함수의 역함이다. (곱셉-나눗셈 처럼)
      - log2(8) = 3 여기서 질문하고 있는 것은 "2 몇승이 값이 8이 되나요?" 이다. 
      - log2(8) = 2^3 즉, log2(value) = exponent = 2^exponent = value
      - 이제부터 이진로그를 그냥 log 라고 하겠다. log === log2 
      - 간단한 규칙을 말하자면, 어떤 이진 로그를 대략 계산하기 위해서는 그 숫자가 1보다 작아지기 전에 2로 나뉘어지는 횟수다.

    🔹 왜 알아야 하는가?
      - 어떤 탐색 알고리즘은 로그 시간복잡도를 가지고 있다.
      - 효율적인 정렬 알고리즘은 로그 알고리즘과 관련이 있다. 
      - 재귀에서 로그 알고리즘이 쓰인다. (특히 공간복잡도 측면)

    <!-- 
      📌 Recap
     -->
     1. 알고리즘의 성능을 분석하기 위해서는 빅오 표기법을 사용한다. 
     2. 입력의 크기가 늘어날수록 전체적인 추세와 관련이 있다.
     3. 실행시간이 어떻게 변하는지, 아니면 공간 복잡도가 어떻게 변하는지를 알아본다.
     4. 빅오를 통해 시간복잡도 및 공간복잡도에 대한 이해를 높일 수 있다.
     5. 측정은 정확도가 아니라 전체적인 추세를 중요하게 생각한다. (그래프)
     6. 빅오로 측정되는 알고리즘의 시간과 공간 복잡도는 하드웨어에 영향을 받지 않는다.
     7. 빅오표기법은 전세계에서 사용된다. 
</body>
</html>