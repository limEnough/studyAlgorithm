!<!DOCTYPE html>
<html lang="ko">
<head>배열과 오브젝트의 성능평가</head>
<body>
  <!--
    📌 Objectives
    1. 빅오의 시점에서 배열과 오브젝트가 어떻게 작동하는지 알아본다.
    2. 배열 앞에 데이터를 추가하면 왜 안좋은지 알아본다. 
    3. 배열과 오브젝트를 처리하는 시간을 비교해보고 더 좋은 대안(메소드)이 있는지 알아본다.
  -->

  <!-- 
    ✅ 객체의 빅오
  -->
  <script>
    let instructor = {
      firstName: "kelly",
      isInstructor: true,
      favoriteNumbers: [1,2,3,4,5]
    }
  </script>

  🔹 언제 객체를 사용하는가?
    - 정렬되어있을 필요가 없을 때
    - 빠른 접근과 입력,제거를 원할 때 

  🔹 빅오 관점에서의 객체
    - 접근/입력/제거할때 소요되는 시간 => 상수 O(1)
    - 탐색에 소요되는 시간 => 선형 O(n)
      탐색이란 어떤 특정한 정보가 있는지 확인하는 방법 (key 값을 알고, 그것을 조회하는 접근과는 다른 이야기)
    
  🔹 빅오 관점에서의 객체 메소드
    - Object.keys => O(n) 아이템 갯수가 늘어날수록 배열에 추가해서 반환하기 때문에
    - Object.values => O(n) 같은 이유
    - Object.entries => O(n) 같은 이유
    - hasOwnProperty => O(1) boolean을 반환하기에 언제나 상수 시간이 소요

  🔹 빅오 관점에서의 객체 메소드
 

  <!-- 
    ✅ 배열의 빅오
  -->
 <script>
    let names = ['지원', '현주', '아름'];
    let values = [ture, {}, [], 2, '문자열']
  </script>
  
  🔹 언제 배열을 사용하는가?
    - 데이터가 정렬될 기준을 가질 때
    - 빠른 접근과 입력 그리고 제거를 원할 때

  🔹 빅오 관점에서의 배열
    - 접근 => 상수 O(1)
    - 입력 => 어디에 입력하는지가 중요하다.
              처음 => 선형 O(n) shift
              끝   => 상수 O(1) push
    - 제거 => 어디에 입력하는지가 중요하다.
              처음 => 선형 O(n) unshift
              끝   => 상수 O(1) pop
    - 탐색 => 선형 O(n)

  🔹 빅오 배열 메소드
    - push => O(1)
    - pop => O(1)
    - shift => O(n)
    - unshift => O(n)
    - concat => O(n)
    - slice => O(n) 복사하는 갯수만큼 늘어난다. 
    - splice => O(n) 
    - sort => O(n * logN) 일반적인 O(n)보다 더 크다. 나중에 더 알아볼 것.
    - forEach/map/filter/reduce/etc. => O(n)

  <!-- 
    ✅ 배열의 빅오
  -->
    
  <!-- 
    📌 Recap
  -->
</body>
</html>